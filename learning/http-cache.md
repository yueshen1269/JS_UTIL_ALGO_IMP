# http 缓存相关

## 概念

* 强缓存：在缓存数据未失效的情况下，不需要再和服务器发生交互
* 协商缓存：需要和服务器发生交互进行比较判断是否可以使用缓存

## 规则

  1. 没有任何缓存则向服务器发起请求
  2. 拥有强缓存规则，则执行强制缓存规则，如果缓存生效就直接使用缓存（200），不在执行协商缓存规则
  3. 没有强缓存或者强缓存失效，并且拥有协商缓存规则，则执行协商缓存规则，如果缓存生效则直接会使用缓存（304）
  4. 没有协商缓存或者协商缓存失效，则向服务器发起资源请求，成功（200）

  tip: 只有响应报文首部设置Cache-Control为非0的max-age或者设置了大于请求日期的Expires才有可能命中强缓存。当满足这个条件，同时响应报文首部中Cache-Control不存在no-cache、no-store且请求报文首部不存在Pragma字段，才会真正命中强缓存

## 缓存优先级

  > Pragma > Cache-Control > Expires > ETag > Last-Modified

## 过程

  1. 如果没有使用缓存，每次都向服务器请求，则有以下缺点
    * 浪费用户流量
    * 浪费服务器资源，服务器要读取资源，然后发送给用户
    * 用户等待时间长，体验差
  2. 将资源直接缓存在本地，未使用任何策略
    优点：用户直接读取缓存资源，减少服务器压力，提高了用户体验
    缺点：资源更新时用户感知不到
  3. 使用Expires字段约定缓存过期时间（绝对时间）
    优点：在过期之后可以重新发起请求，获得最新资源
    缺点：
      * 用户本地时间不准，可能导致缓存永远失效
      * 缓存过期后，从服务器获取的资源可能没有变化
  4. 使用Cache-Control 使用相对时间
    优点：cache-control: max-age=31536000 ,使用相对时间，在31536000秒内使用缓存资源
  5. 服务器告知用户资源上次更改时间
    优点：用户请求时带上if-modified-since头部请求服务器时，如果资源更新时间没有发生变化，则返回304，告知用户可以使用缓存
    缺点：
      * 资源更新时间只能精确到秒，如果一秒内更改多次，则不会获得最新
      * 如果资源更新了，但内容没有任何变化，则会返回与用户本地缓存相同的资源
  6. 使用ETag--资源的唯一标识
    优点：用户请求时带上if-none-match头部请求服务器时，服务器或将头部的值与被请求资源的ETag对比，如果相同则返回304
    缺点：ETag的计算会占用服务器的资源
  7. 通过给js、css、图片等资源设置版本号，并且



## 强缓存字段

### Pragma

1. `Pragma`是HTTP/1.1之前版本遗留的通用首部字段，仅作为于HTTP/1.0的向后兼容而使用。虽然它是一个通用首部，但是它在响应报文中时的行为没有规范，依赖于浏览器的实现。RFC中该字段只有`no-cache`一个可选值，会通知浏览器不直接使用缓存，要求向服务器发请求校验新鲜度
2. 优先级最高
3. 字段存在时一定不会命中强缓存

### cache-control 相关字段

* `no-cache`: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验，无论是响应报文首部还是请求报文首部出现这个字段均一定不会命中强缓存
* `must-revalidate`：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验
* `private`: 只有客户端可以缓存
* `public`: 客户端和代理服务器都可缓存
* `no-store`: 所有内容都不会缓存，强制缓存，协商缓存都不会触发
* `max-age`: 设置缓存的存在时间，相对于发送请求的时间，单位为秒。

## 协商缓存字段

### Last-Modified/If-Modified-Since
  `If-Modified-Since`是一个请求首部字段，并且只能用在GET或者HEAD请求中
  `Last-Modified`是一个响应首部字段，包含服务器认定的资源作出修改的日期及时间

### ETag/If-None-Match
  `ETag`优先级比`Last-Modified`高
